{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;\n\nvar h264 = __importStar(require(\"h264-profile-level-id\"));\n\nvar utils = __importStar(require(\"./utils\"));\n\nvar RTP_PROBATOR_MID = 'probator';\nvar RTP_PROBATOR_SSRC = 1234;\nvar RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCapabilities(caps) {\n  if (typeof caps !== 'object') {\n    throw new TypeError('caps is not an object');\n  } // codecs is optional. If unset, fill with an empty array.\n\n\n  if (caps.codecs && !Array.isArray(caps.codecs)) {\n    throw new TypeError('caps.codecs is not an array');\n  } else if (!caps.codecs) {\n    caps.codecs = [];\n  }\n\n  var _iterator = _createForOfIteratorHelper(caps.codecs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var codec = _step.value;\n      validateRtpCodecCapability(codec);\n    } // headerExtensions is optional. If unset, fill with an empty array.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {\n    throw new TypeError('caps.headerExtensions is not an array');\n  } else if (!caps.headerExtensions) {\n    caps.headerExtensions = [];\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(caps.headerExtensions),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var ext = _step2.value;\n      validateRtpHeaderExtension(ext);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCodecCapability(codec) {\n  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n\n  if (typeof codec !== 'object') {\n    throw new TypeError('codec is not an object');\n  } // mimeType is mandatory.\n\n\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n    throw new TypeError('missing codec.mimeType');\n  }\n\n  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n\n  if (!mimeTypeMatch) {\n    throw new TypeError('invalid codec.mimeType');\n  } // Just override kind with media component of mimeType.\n\n\n  codec.kind = mimeTypeMatch[1].toLowerCase(); // preferredPayloadType is optional.\n\n  if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number') {\n    throw new TypeError('invalid codec.preferredPayloadType');\n  } // clockRate is mandatory.\n\n\n  if (typeof codec.clockRate !== 'number') {\n    throw new TypeError('missing codec.clockRate');\n  } // channels is optional. If unset, set it to 1 (just if audio).\n\n\n  if (codec.kind === 'audio') {\n    if (typeof codec.channels !== 'number') {\n      codec.channels = 1;\n    }\n  } else {\n    delete codec.channels;\n  } // parameters is optional. If unset, set it to an empty object.\n\n\n  if (!codec.parameters || typeof codec.parameters !== 'object') {\n    codec.parameters = {};\n  }\n\n  for (var _i = 0, _Object$keys = Object.keys(codec.parameters); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var value = codec.parameters[key];\n\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(\"invalid codec parameter [key:\".concat(key, \"s, value:\").concat(value, \"]\"));\n    } // Specific parameters validation.\n\n\n    if (key === 'apt') {\n      if (typeof value !== 'number') {\n        throw new TypeError('invalid codec apt parameter');\n      }\n    }\n  } // rtcpFeedback is optional. If unset, set it to an empty array.\n\n\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n    codec.rtcpFeedback = [];\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(codec.rtcpFeedback),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var fb = _step3.value;\n      validateRtcpFeedback(fb);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtcpFeedback(fb) {\n  if (typeof fb !== 'object') {\n    throw new TypeError('fb is not an object');\n  } // type is mandatory.\n\n\n  if (!fb.type || typeof fb.type !== 'string') {\n    throw new TypeError('missing fb.type');\n  } // parameter is optional. If unset set it to an empty string.\n\n\n  if (!fb.parameter || typeof fb.parameter !== 'string') {\n    fb.parameter = '';\n  }\n}\n\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpHeaderExtension(ext) {\n  if (typeof ext !== 'object') {\n    throw new TypeError('ext is not an object');\n  } // kind is mandatory.\n\n\n  if (ext.kind !== 'audio' && ext.kind !== 'video') {\n    throw new TypeError('invalid ext.kind');\n  } // uri is mandatory.\n\n\n  if (!ext.uri || typeof ext.uri !== 'string') {\n    throw new TypeError('missing ext.uri');\n  } // preferredId is mandatory.\n\n\n  if (typeof ext.preferredId !== 'number') {\n    throw new TypeError('missing ext.preferredId');\n  } // preferredEncrypt is optional. If unset set it to false.\n\n\n  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {\n    throw new TypeError('invalid ext.preferredEncrypt');\n  } else if (!ext.preferredEncrypt) {\n    ext.preferredEncrypt = false;\n  } // direction is optional. If unset set it to sendrecv.\n\n\n  if (ext.direction && typeof ext.direction !== 'string') {\n    throw new TypeError('invalid ext.direction');\n  } else if (!ext.direction) {\n    ext.direction = 'sendrecv';\n  }\n}\n\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpParameters(params) {\n  if (typeof params !== 'object') {\n    throw new TypeError('params is not an object');\n  } // mid is optional.\n\n\n  if (params.mid && typeof params.mid !== 'string') {\n    throw new TypeError('params.mid is not a string');\n  } // codecs is mandatory.\n\n\n  if (!Array.isArray(params.codecs)) {\n    throw new TypeError('missing params.codecs');\n  }\n\n  var _iterator4 = _createForOfIteratorHelper(params.codecs),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var codec = _step4.value;\n      validateRtpCodecParameters(codec);\n    } // headerExtensions is optional. If unset, fill with an empty array.\n\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {\n    throw new TypeError('params.headerExtensions is not an array');\n  } else if (!params.headerExtensions) {\n    params.headerExtensions = [];\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(params.headerExtensions),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var ext = _step5.value;\n      validateRtpHeaderExtensionParameters(ext);\n    } // encodings is optional. If unset, fill with an empty array.\n\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  if (params.encodings && !Array.isArray(params.encodings)) {\n    throw new TypeError('params.encodings is not an array');\n  } else if (!params.encodings) {\n    params.encodings = [];\n  }\n\n  var _iterator6 = _createForOfIteratorHelper(params.encodings),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var encoding = _step6.value;\n      validateRtpEncodingParameters(encoding);\n    } // rtcp is optional. If unset, fill with an empty object.\n\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  if (params.rtcp && typeof params.rtcp !== 'object') {\n    throw new TypeError('params.rtcp is not an object');\n  } else if (!params.rtcp) {\n    params.rtcp = {};\n  }\n\n  validateRtcpParameters(params.rtcp);\n}\n\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCodecParameters(codec) {\n  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n\n  if (typeof codec !== 'object') {\n    throw new TypeError('codec is not an object');\n  } // mimeType is mandatory.\n\n\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n    throw new TypeError('missing codec.mimeType');\n  }\n\n  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n\n  if (!mimeTypeMatch) {\n    throw new TypeError('invalid codec.mimeType');\n  } // payloadType is mandatory.\n\n\n  if (typeof codec.payloadType !== 'number') {\n    throw new TypeError('missing codec.payloadType');\n  } // clockRate is mandatory.\n\n\n  if (typeof codec.clockRate !== 'number') {\n    throw new TypeError('missing codec.clockRate');\n  }\n\n  var kind = mimeTypeMatch[1].toLowerCase(); // channels is optional. If unset, set it to 1 (just if audio).\n\n  if (kind === 'audio') {\n    if (typeof codec.channels !== 'number') {\n      codec.channels = 1;\n    }\n  } else {\n    delete codec.channels;\n  } // parameters is optional. If unset, set it to an empty object.\n\n\n  if (!codec.parameters || typeof codec.parameters !== 'object') {\n    codec.parameters = {};\n  }\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(codec.parameters); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    var value = codec.parameters[key];\n\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(\"invalid codec parameter [key:\".concat(key, \"s, value:\").concat(value, \"]\"));\n    } // Specific parameters validation.\n\n\n    if (key === 'apt') {\n      if (typeof value !== 'number') {\n        throw new TypeError('invalid codec apt parameter');\n      }\n    }\n  } // rtcpFeedback is optional. If unset, set it to an empty array.\n\n\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n    codec.rtcpFeedback = [];\n  }\n\n  var _iterator7 = _createForOfIteratorHelper(codec.rtcpFeedback),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var fb = _step7.value;\n      validateRtcpFeedback(fb);\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\n\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpHeaderExtensionParameters(ext) {\n  if (typeof ext !== 'object') {\n    throw new TypeError('ext is not an object');\n  } // uri is mandatory.\n\n\n  if (!ext.uri || typeof ext.uri !== 'string') {\n    throw new TypeError('missing ext.uri');\n  } // id is mandatory.\n\n\n  if (typeof ext.id !== 'number') {\n    throw new TypeError('missing ext.id');\n  } // encrypt is optional. If unset set it to false.\n\n\n  if (ext.encrypt && typeof ext.encrypt !== 'boolean') {\n    throw new TypeError('invalid ext.encrypt');\n  } else if (!ext.encrypt) {\n    ext.encrypt = false;\n  } // parameters is optional. If unset, set it to an empty object.\n\n\n  if (!ext.parameters || typeof ext.parameters !== 'object') {\n    ext.parameters = {};\n  }\n\n  for (var _i3 = 0, _Object$keys3 = Object.keys(ext.parameters); _i3 < _Object$keys3.length; _i3++) {\n    var key = _Object$keys3[_i3];\n    var value = ext.parameters[key];\n\n    if (value === undefined) {\n      ext.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError('invalid header extension parameter');\n    }\n  }\n}\n\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpEncodingParameters(encoding) {\n  if (typeof encoding !== 'object') {\n    throw new TypeError('encoding is not an object');\n  } // ssrc is optional.\n\n\n  if (encoding.ssrc && typeof encoding.ssrc !== 'number') {\n    throw new TypeError('invalid encoding.ssrc');\n  } // rid is optional.\n\n\n  if (encoding.rid && typeof encoding.rid !== 'string') {\n    throw new TypeError('invalid encoding.rid');\n  } // rtx is optional.\n\n\n  if (encoding.rtx && typeof encoding.rtx !== 'object') {\n    throw new TypeError('invalid encoding.rtx');\n  } else if (encoding.rtx) {\n    // RTX ssrc is mandatory if rtx is present.\n    if (typeof encoding.rtx.ssrc !== 'number') {\n      throw new TypeError('missing encoding.rtx.ssrc');\n    }\n  } // dtx is optional. If unset set it to false.\n\n\n  if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {\n    encoding.dtx = false;\n  } // scalabilityMode is optional.\n\n\n  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') {\n    throw new TypeError('invalid encoding.scalabilityMode');\n  }\n}\n\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtcpParameters(rtcp) {\n  if (typeof rtcp !== 'object') {\n    throw new TypeError('rtcp is not an object');\n  } // cname is optional.\n\n\n  if (rtcp.cname && typeof rtcp.cname !== 'string') {\n    throw new TypeError('invalid rtcp.cname');\n  } // reducedSize is optional. If unset set it to true.\n\n\n  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {\n    rtcp.reducedSize = true;\n  }\n}\n\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpCapabilities(caps) {\n  if (typeof caps !== 'object') {\n    throw new TypeError('caps is not an object');\n  } // numStreams is mandatory.\n\n\n  if (!caps.numStreams || typeof caps.numStreams !== 'object') {\n    throw new TypeError('missing caps.numStreams');\n  }\n\n  validateNumSctpStreams(caps.numStreams);\n}\n\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateNumSctpStreams(numStreams) {\n  if (typeof numStreams !== 'object') {\n    throw new TypeError('numStreams is not an object');\n  } // OS is mandatory.\n\n\n  if (typeof numStreams.OS !== 'number') {\n    throw new TypeError('missing numStreams.OS');\n  } // MIS is mandatory.\n\n\n  if (typeof numStreams.MIS !== 'number') {\n    throw new TypeError('missing numStreams.MIS');\n  }\n}\n\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpParameters(params) {\n  if (typeof params !== 'object') {\n    throw new TypeError('params is not an object');\n  } // port is mandatory.\n\n\n  if (typeof params.port !== 'number') {\n    throw new TypeError('missing params.port');\n  } // OS is mandatory.\n\n\n  if (typeof params.OS !== 'number') {\n    throw new TypeError('missing params.OS');\n  } // MIS is mandatory.\n\n\n  if (typeof params.MIS !== 'number') {\n    throw new TypeError('missing params.MIS');\n  } // maxMessageSize is mandatory.\n\n\n  if (typeof params.maxMessageSize !== 'number') {\n    throw new TypeError('missing params.maxMessageSize');\n  }\n}\n\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpStreamParameters(params) {\n  if (typeof params !== 'object') {\n    throw new TypeError('params is not an object');\n  } // streamId is mandatory.\n\n\n  if (typeof params.streamId !== 'number') {\n    throw new TypeError('missing params.streamId');\n  } // ordered is optional.\n\n\n  var orderedGiven = false;\n\n  if (typeof params.ordered === 'boolean') {\n    orderedGiven = true;\n  } else {\n    params.ordered = true;\n  } // maxPacketLifeTime is optional.\n\n\n  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') {\n    throw new TypeError('invalid params.maxPacketLifeTime');\n  } // maxRetransmits is optional.\n\n\n  if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {\n    throw new TypeError('invalid params.maxRetransmits');\n  }\n\n  if (params.maxPacketLifeTime && params.maxRetransmits) {\n    throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n  }\n\n  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    params.ordered = false;\n  } // label is optional.\n\n\n  if (params.label && typeof params.label !== 'string') {\n    throw new TypeError('invalid params.label');\n  } // protocol is optional.\n\n\n  if (params.protocol && typeof params.protocol !== 'string') {\n    throw new TypeError('invalid params.protocol');\n  }\n}\n\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\n\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n  var extendedRtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  }; // Match media codecs and keep the order preferred by remoteCaps.\n\n  var _iterator8 = _createForOfIteratorHelper(remoteCaps.codecs || []),\n      _step8;\n\n  try {\n    var _loop = function _loop() {\n      var remoteCodec = _step8.value;\n\n      if (isRtxCodec(remoteCodec)) {\n        return \"continue\";\n      }\n\n      var matchingLocalCodec = (localCaps.codecs || []).find(function (localCodec) {\n        return matchCodecs(localCodec, remoteCodec, {\n          strict: true,\n          modify: true\n        });\n      });\n\n      if (!matchingLocalCodec) {\n        return \"continue\";\n      }\n\n      var extendedCodec = {\n        mimeType: matchingLocalCodec.mimeType,\n        kind: matchingLocalCodec.kind,\n        clockRate: matchingLocalCodec.clockRate,\n        channels: matchingLocalCodec.channels,\n        localPayloadType: matchingLocalCodec.preferredPayloadType,\n        localRtxPayloadType: undefined,\n        remotePayloadType: remoteCodec.preferredPayloadType,\n        remoteRtxPayloadType: undefined,\n        localParameters: matchingLocalCodec.parameters,\n        remoteParameters: remoteCodec.parameters,\n        rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n      };\n      extendedRtpCapabilities.codecs.push(extendedCodec);\n    };\n\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    } // Match RTX codecs.\n\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  var _iterator9 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),\n      _step9;\n\n  try {\n    var _loop2 = function _loop2() {\n      var extendedCodec = _step9.value;\n      var matchingLocalRtxCodec = localCaps.codecs.find(function (localCodec) {\n        return isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType;\n      });\n      var matchingRemoteRtxCodec = remoteCaps.codecs.find(function (remoteCodec) {\n        return isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType;\n      });\n\n      if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n        extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n        extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n      }\n    };\n\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      _loop2();\n    } // Match header extensions.\n\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  var _iterator10 = _createForOfIteratorHelper(remoteCaps.headerExtensions),\n      _step10;\n\n  try {\n    var _loop3 = function _loop3() {\n      var remoteExt = _step10.value;\n      var matchingLocalExt = localCaps.headerExtensions.find(function (localExt) {\n        return matchHeaderExtensions(localExt, remoteExt);\n      });\n\n      if (!matchingLocalExt) {\n        return \"continue\";\n      }\n\n      var extendedExt = {\n        kind: remoteExt.kind,\n        uri: remoteExt.uri,\n        sendId: matchingLocalExt.preferredId,\n        recvId: remoteExt.preferredId,\n        encrypt: matchingLocalExt.preferredEncrypt,\n        direction: 'sendrecv'\n      };\n\n      switch (remoteExt.direction) {\n        case 'sendrecv':\n          extendedExt.direction = 'sendrecv';\n          break;\n\n        case 'recvonly':\n          extendedExt.direction = 'sendonly';\n          break;\n\n        case 'sendonly':\n          extendedExt.direction = 'recvonly';\n          break;\n\n        case 'inactive':\n          extendedExt.direction = 'inactive';\n          break;\n      }\n\n      extendedRtpCapabilities.headerExtensions.push(extendedExt);\n    };\n\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var _ret2 = _loop3();\n\n      if (_ret2 === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return extendedRtpCapabilities;\n}\n\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\n\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n  var rtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  };\n\n  var _iterator11 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var extendedCodec = _step11.value;\n      var codec = {\n        mimeType: extendedCodec.mimeType,\n        kind: extendedCodec.kind,\n        preferredPayloadType: extendedCodec.remotePayloadType,\n        clockRate: extendedCodec.clockRate,\n        channels: extendedCodec.channels,\n        parameters: extendedCodec.localParameters,\n        rtcpFeedback: extendedCodec.rtcpFeedback\n      };\n      rtpCapabilities.codecs.push(codec); // Add RTX codec.\n\n      if (!extendedCodec.remoteRtxPayloadType) {\n        continue;\n      }\n\n      var rtxCodec = {\n        mimeType: \"\".concat(extendedCodec.kind, \"/rtx\"),\n        kind: extendedCodec.kind,\n        preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n        clockRate: extendedCodec.clockRate,\n        parameters: {\n          apt: extendedCodec.remotePayloadType\n        },\n        rtcpFeedback: []\n      };\n      rtpCapabilities.codecs.push(rtxCodec); // TODO: In the future, we need to add FEC, CN, etc, codecs.\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  var _iterator12 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var extendedExtension = _step12.value;\n\n      // Ignore RTP extensions not valid for receiving.\n      if (extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'recvonly') {\n        continue;\n      }\n\n      var ext = {\n        kind: extendedExtension.kind,\n        uri: extendedExtension.uri,\n        preferredId: extendedExtension.recvId,\n        preferredEncrypt: extendedExtension.encrypt,\n        direction: extendedExtension.direction\n      };\n      rtpCapabilities.headerExtensions.push(ext);\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return rtpCapabilities;\n}\n\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\n\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n  var rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n\n  var _iterator13 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var extendedCodec = _step13.value;\n\n      if (extendedCodec.kind !== kind) {\n        continue;\n      }\n\n      var codec = {\n        mimeType: extendedCodec.mimeType,\n        payloadType: extendedCodec.localPayloadType,\n        clockRate: extendedCodec.clockRate,\n        channels: extendedCodec.channels,\n        parameters: extendedCodec.localParameters,\n        rtcpFeedback: extendedCodec.rtcpFeedback\n      };\n      rtpParameters.codecs.push(codec); // Add RTX codec.\n\n      if (extendedCodec.localRtxPayloadType) {\n        var rtxCodec = {\n          mimeType: \"\".concat(extendedCodec.kind, \"/rtx\"),\n          payloadType: extendedCodec.localRtxPayloadType,\n          clockRate: extendedCodec.clockRate,\n          parameters: {\n            apt: extendedCodec.localPayloadType\n          },\n          rtcpFeedback: []\n        };\n        rtpParameters.codecs.push(rtxCodec);\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  var _iterator14 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),\n      _step14;\n\n  try {\n    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n      var extendedExtension = _step14.value;\n\n      // Ignore RTP extensions of a different kind and those not valid for sending.\n      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n        continue;\n      }\n\n      var ext = {\n        uri: extendedExtension.uri,\n        id: extendedExtension.sendId,\n        encrypt: extendedExtension.encrypt,\n        parameters: {}\n      };\n      rtpParameters.headerExtensions.push(ext);\n    }\n  } catch (err) {\n    _iterator14.e(err);\n  } finally {\n    _iterator14.f();\n  }\n\n  return rtpParameters;\n}\n\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\n\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n  var rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n\n  var _iterator15 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),\n      _step15;\n\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var extendedCodec = _step15.value;\n\n      if (extendedCodec.kind !== kind) {\n        continue;\n      }\n\n      var _codec3 = {\n        mimeType: extendedCodec.mimeType,\n        payloadType: extendedCodec.localPayloadType,\n        clockRate: extendedCodec.clockRate,\n        channels: extendedCodec.channels,\n        parameters: extendedCodec.remoteParameters,\n        rtcpFeedback: extendedCodec.rtcpFeedback\n      };\n      rtpParameters.codecs.push(_codec3); // Add RTX codec.\n\n      if (extendedCodec.localRtxPayloadType) {\n        var rtxCodec = {\n          mimeType: \"\".concat(extendedCodec.kind, \"/rtx\"),\n          payloadType: extendedCodec.localRtxPayloadType,\n          clockRate: extendedCodec.clockRate,\n          parameters: {\n            apt: extendedCodec.localPayloadType\n          },\n          rtcpFeedback: []\n        };\n        rtpParameters.codecs.push(rtxCodec);\n      }\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n\n  var _iterator16 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),\n      _step16;\n\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var extendedExtension = _step16.value;\n\n      // Ignore RTP extensions of a different kind and those not valid for sending.\n      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n        continue;\n      }\n\n      var ext = {\n        uri: extendedExtension.uri,\n        id: extendedExtension.sendId,\n        encrypt: extendedExtension.encrypt,\n        parameters: {}\n      };\n      rtpParameters.headerExtensions.push(ext);\n    } // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n\n  if (rtpParameters.headerExtensions.some(function (ext) {\n    return ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01';\n  })) {\n    var _iterator17 = _createForOfIteratorHelper(rtpParameters.codecs),\n        _step17;\n\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var codec = _step17.value;\n        codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(function (fb) {\n          return fb.type !== 'goog-remb';\n        });\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n  } else if (rtpParameters.headerExtensions.some(function (ext) {\n    return ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time';\n  })) {\n    var _iterator18 = _createForOfIteratorHelper(rtpParameters.codecs),\n        _step18;\n\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var _codec = _step18.value;\n        _codec.rtcpFeedback = (_codec.rtcpFeedback || []).filter(function (fb) {\n          return fb.type !== 'transport-cc';\n        });\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n  } else {\n    var _iterator19 = _createForOfIteratorHelper(rtpParameters.codecs),\n        _step19;\n\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var _codec2 = _step19.value;\n        _codec2.rtcpFeedback = (_codec2.rtcpFeedback || []).filter(function (fb) {\n          return fb.type !== 'transport-cc' && fb.type !== 'goog-remb';\n        });\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n  }\n\n  return rtpParameters;\n}\n\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\n\nfunction reduceCodecs(codecs, capCodec) {\n  var filteredCodecs = []; // If no capability codec is given, take the first one (and RTX).\n\n  if (!capCodec) {\n    filteredCodecs.push(codecs[0]);\n\n    if (isRtxCodec(codecs[1])) {\n      filteredCodecs.push(codecs[1]);\n    }\n  } // Otherwise look for a compatible set of codecs.\n  else {\n    for (var idx = 0; idx < codecs.length; ++idx) {\n      if (matchCodecs(codecs[idx], capCodec)) {\n        filteredCodecs.push(codecs[idx]);\n\n        if (isRtxCodec(codecs[idx + 1])) {\n          filteredCodecs.push(codecs[idx + 1]);\n        }\n\n        break;\n      }\n    }\n\n    if (filteredCodecs.length === 0) {\n      throw new TypeError('no matching codec found');\n    }\n  }\n\n  return filteredCodecs;\n}\n\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\n\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n  // Clone given reference video RTP parameters.\n  videoRtpParameters = utils.clone(videoRtpParameters, {}); // This may throw.\n\n  validateRtpParameters(videoRtpParameters);\n  var rtpParameters = {\n    mid: RTP_PROBATOR_MID,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [{\n      ssrc: RTP_PROBATOR_SSRC\n    }],\n    rtcp: {\n      cname: 'probator'\n    }\n  };\n  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n  return rtpParameters;\n}\n\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\n\nfunction canSend(kind, extendedRtpCapabilities) {\n  return extendedRtpCapabilities.codecs.some(function (codec) {\n    return codec.kind === kind;\n  });\n}\n\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\n\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n  // This may throw.\n  validateRtpParameters(rtpParameters);\n\n  if (rtpParameters.codecs.length === 0) {\n    return false;\n  }\n\n  var firstMediaCodec = rtpParameters.codecs[0];\n  return extendedRtpCapabilities.codecs.some(function (codec) {\n    return codec.remotePayloadType === firstMediaCodec.payloadType;\n  });\n}\n\nexports.canReceive = canReceive;\n\nfunction isRtxCodec(codec) {\n  if (!codec) {\n    return false;\n  }\n\n  return /.+\\/rtx$/i.test(codec.mimeType);\n}\n\nfunction matchCodecs(aCodec, bCodec) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$strict = _ref.strict,\n      strict = _ref$strict === void 0 ? false : _ref$strict,\n      _ref$modify = _ref.modify,\n      modify = _ref$modify === void 0 ? false : _ref$modify;\n\n  var aMimeType = aCodec.mimeType.toLowerCase();\n  var bMimeType = bCodec.mimeType.toLowerCase();\n\n  if (aMimeType !== bMimeType) {\n    return false;\n  }\n\n  if (aCodec.clockRate !== bCodec.clockRate) {\n    return false;\n  }\n\n  if (aCodec.channels !== bCodec.channels) {\n    return false;\n  } // Per codec special checks.\n\n\n  switch (aMimeType) {\n    case 'video/h264':\n      {\n        if (strict) {\n          var aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n          var bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n\n          if (aPacketizationMode !== bPacketizationMode) {\n            return false;\n          }\n\n          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {\n            return false;\n          }\n\n          var selectedProfileLevelId;\n\n          try {\n            selectedProfileLevelId = h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\n          } catch (error) {\n            return false;\n          }\n\n          if (modify) {\n            if (selectedProfileLevelId) {\n              aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n              bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n            } else {\n              delete aCodec.parameters['profile-level-id'];\n              delete bCodec.parameters['profile-level-id'];\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'video/vp9':\n      {\n        if (strict) {\n          var aProfileId = aCodec.parameters['profile-id'] || 0;\n          var bProfileId = bCodec.parameters['profile-id'] || 0;\n\n          if (aProfileId !== bProfileId) {\n            return false;\n          }\n        }\n\n        break;\n      }\n  }\n\n  return true;\n}\n\nfunction matchHeaderExtensions(aExt, bExt) {\n  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {\n    return false;\n  }\n\n  if (aExt.uri !== bExt.uri) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction reduceRtcpFeedback(codecA, codecB) {\n  var reducedRtcpFeedback = [];\n\n  var _iterator20 = _createForOfIteratorHelper(codecA.rtcpFeedback || []),\n      _step20;\n\n  try {\n    var _loop4 = function _loop4() {\n      var aFb = _step20.value;\n      var matchingBFb = (codecB.rtcpFeedback || []).find(function (bFb) {\n        return bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter);\n      });\n\n      if (matchingBFb) {\n        reducedRtcpFeedback.push(matchingBFb);\n      }\n    };\n\n    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n      _loop4();\n    }\n  } catch (err) {\n    _iterator20.e(err);\n  } finally {\n    _iterator20.f();\n  }\n\n  return reducedRtcpFeedback;\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","canReceive","canSend","generateProbatorRtpParameters","reduceCodecs","getSendingRemoteRtpParameters","getSendingRtpParameters","getRecvRtpCapabilities","getExtendedRtpCapabilities","validateSctpStreamParameters","validateSctpParameters","validateNumSctpStreams","validateSctpCapabilities","validateRtcpParameters","validateRtpEncodingParameters","validateRtpHeaderExtensionParameters","validateRtpCodecParameters","validateRtpParameters","validateRtpHeaderExtension","validateRtcpFeedback","validateRtpCodecCapability","validateRtpCapabilities","h264","require","utils","RTP_PROBATOR_MID","RTP_PROBATOR_SSRC","RTP_PROBATOR_CODEC_PAYLOAD_TYPE","caps","TypeError","codecs","Array","isArray","codec","headerExtensions","ext","MimeTypeRegex","RegExp","mimeType","mimeTypeMatch","exec","kind","toLowerCase","preferredPayloadType","clockRate","channels","parameters","keys","key","rtcpFeedback","fb","type","parameter","uri","preferredId","preferredEncrypt","direction","params","mid","encodings","encoding","rtcp","payloadType","id","encrypt","ssrc","rid","rtx","dtx","scalabilityMode","cname","reducedSize","numStreams","OS","MIS","port","maxMessageSize","streamId","orderedGiven","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","localCaps","remoteCaps","extendedRtpCapabilities","remoteCodec","isRtxCodec","matchingLocalCodec","find","localCodec","matchCodecs","strict","modify","extendedCodec","localPayloadType","localRtxPayloadType","remotePayloadType","remoteRtxPayloadType","localParameters","remoteParameters","reduceRtcpFeedback","push","matchingLocalRtxCodec","apt","matchingRemoteRtxCodec","remoteExt","matchingLocalExt","localExt","matchHeaderExtensions","extendedExt","sendId","recvId","rtpCapabilities","rtxCodec","extendedExtension","rtpParameters","some","filter","capCodec","filteredCodecs","idx","length","videoRtpParameters","clone","firstMediaCodec","test","aCodec","bCodec","aMimeType","bMimeType","aPacketizationMode","bPacketizationMode","isSameProfile","selectedProfileLevelId","generateProfileLevelIdForAnswer","error","aProfileId","bProfileId","aExt","bExt","codecA","codecB","reducedRtcpFeedback","aFb","matchingBFb","bFb"],"sources":["/home/runner/work/watchparty/watchparty/node_modules/mediasoup-client/lib/ortc.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;\nconst h264 = __importStar(require(\"h264-profile-level-id\"));\nconst utils = __importStar(require(\"./utils\"));\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCapabilities(caps) {\n    if (typeof caps !== 'object') {\n        throw new TypeError('caps is not an object');\n    }\n    // codecs is optional. If unset, fill with an empty array.\n    if (caps.codecs && !Array.isArray(caps.codecs)) {\n        throw new TypeError('caps.codecs is not an array');\n    }\n    else if (!caps.codecs) {\n        caps.codecs = [];\n    }\n    for (const codec of caps.codecs) {\n        validateRtpCodecCapability(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {\n        throw new TypeError('caps.headerExtensions is not an array');\n    }\n    else if (!caps.headerExtensions) {\n        caps.headerExtensions = [];\n    }\n    for (const ext of caps.headerExtensions) {\n        validateRtpHeaderExtension(ext);\n    }\n}\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecCapability(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object') {\n        throw new TypeError('codec is not an object');\n    }\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n        throw new TypeError('missing codec.mimeType');\n    }\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch) {\n        throw new TypeError('invalid codec.mimeType');\n    }\n    // Just override kind with media component of mimeType.\n    codec.kind = mimeTypeMatch[1].toLowerCase();\n    // preferredPayloadType is optional.\n    if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number') {\n        throw new TypeError('invalid codec.preferredPayloadType');\n    }\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number') {\n        throw new TypeError('missing codec.clockRate');\n    }\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (codec.kind === 'audio') {\n        if (typeof codec.channels !== 'number') {\n            codec.channels = 1;\n        }\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object') {\n        codec.parameters = {};\n    }\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number') {\n                throw new TypeError('invalid codec apt parameter');\n            }\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n        codec.rtcpFeedback = [];\n    }\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpFeedback(fb) {\n    if (typeof fb !== 'object') {\n        throw new TypeError('fb is not an object');\n    }\n    // type is mandatory.\n    if (!fb.type || typeof fb.type !== 'string') {\n        throw new TypeError('missing fb.type');\n    }\n    // parameter is optional. If unset set it to an empty string.\n    if (!fb.parameter || typeof fb.parameter !== 'string') {\n        fb.parameter = '';\n    }\n}\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtension(ext) {\n    if (typeof ext !== 'object') {\n        throw new TypeError('ext is not an object');\n    }\n    // kind is mandatory.\n    if (ext.kind !== 'audio' && ext.kind !== 'video') {\n        throw new TypeError('invalid ext.kind');\n    }\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string') {\n        throw new TypeError('missing ext.uri');\n    }\n    // preferredId is mandatory.\n    if (typeof ext.preferredId !== 'number') {\n        throw new TypeError('missing ext.preferredId');\n    }\n    // preferredEncrypt is optional. If unset set it to false.\n    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {\n        throw new TypeError('invalid ext.preferredEncrypt');\n    }\n    else if (!ext.preferredEncrypt) {\n        ext.preferredEncrypt = false;\n    }\n    // direction is optional. If unset set it to sendrecv.\n    if (ext.direction && typeof ext.direction !== 'string') {\n        throw new TypeError('invalid ext.direction');\n    }\n    else if (!ext.direction) {\n        ext.direction = 'sendrecv';\n    }\n}\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpParameters(params) {\n    if (typeof params !== 'object') {\n        throw new TypeError('params is not an object');\n    }\n    // mid is optional.\n    if (params.mid && typeof params.mid !== 'string') {\n        throw new TypeError('params.mid is not a string');\n    }\n    // codecs is mandatory.\n    if (!Array.isArray(params.codecs)) {\n        throw new TypeError('missing params.codecs');\n    }\n    for (const codec of params.codecs) {\n        validateRtpCodecParameters(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {\n        throw new TypeError('params.headerExtensions is not an array');\n    }\n    else if (!params.headerExtensions) {\n        params.headerExtensions = [];\n    }\n    for (const ext of params.headerExtensions) {\n        validateRtpHeaderExtensionParameters(ext);\n    }\n    // encodings is optional. If unset, fill with an empty array.\n    if (params.encodings && !Array.isArray(params.encodings)) {\n        throw new TypeError('params.encodings is not an array');\n    }\n    else if (!params.encodings) {\n        params.encodings = [];\n    }\n    for (const encoding of params.encodings) {\n        validateRtpEncodingParameters(encoding);\n    }\n    // rtcp is optional. If unset, fill with an empty object.\n    if (params.rtcp && typeof params.rtcp !== 'object') {\n        throw new TypeError('params.rtcp is not an object');\n    }\n    else if (!params.rtcp) {\n        params.rtcp = {};\n    }\n    validateRtcpParameters(params.rtcp);\n}\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecParameters(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object') {\n        throw new TypeError('codec is not an object');\n    }\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string') {\n        throw new TypeError('missing codec.mimeType');\n    }\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch) {\n        throw new TypeError('invalid codec.mimeType');\n    }\n    // payloadType is mandatory.\n    if (typeof codec.payloadType !== 'number') {\n        throw new TypeError('missing codec.payloadType');\n    }\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number') {\n        throw new TypeError('missing codec.clockRate');\n    }\n    const kind = mimeTypeMatch[1].toLowerCase();\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (kind === 'audio') {\n        if (typeof codec.channels !== 'number') {\n            codec.channels = 1;\n        }\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object') {\n        codec.parameters = {};\n    }\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number') {\n                throw new TypeError('invalid codec apt parameter');\n            }\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {\n        codec.rtcpFeedback = [];\n    }\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtensionParameters(ext) {\n    if (typeof ext !== 'object') {\n        throw new TypeError('ext is not an object');\n    }\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string') {\n        throw new TypeError('missing ext.uri');\n    }\n    // id is mandatory.\n    if (typeof ext.id !== 'number') {\n        throw new TypeError('missing ext.id');\n    }\n    // encrypt is optional. If unset set it to false.\n    if (ext.encrypt && typeof ext.encrypt !== 'boolean') {\n        throw new TypeError('invalid ext.encrypt');\n    }\n    else if (!ext.encrypt) {\n        ext.encrypt = false;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!ext.parameters || typeof ext.parameters !== 'object') {\n        ext.parameters = {};\n    }\n    for (const key of Object.keys(ext.parameters)) {\n        let value = ext.parameters[key];\n        if (value === undefined) {\n            ext.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError('invalid header extension parameter');\n        }\n    }\n}\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpEncodingParameters(encoding) {\n    if (typeof encoding !== 'object') {\n        throw new TypeError('encoding is not an object');\n    }\n    // ssrc is optional.\n    if (encoding.ssrc && typeof encoding.ssrc !== 'number') {\n        throw new TypeError('invalid encoding.ssrc');\n    }\n    // rid is optional.\n    if (encoding.rid && typeof encoding.rid !== 'string') {\n        throw new TypeError('invalid encoding.rid');\n    }\n    // rtx is optional.\n    if (encoding.rtx && typeof encoding.rtx !== 'object') {\n        throw new TypeError('invalid encoding.rtx');\n    }\n    else if (encoding.rtx) {\n        // RTX ssrc is mandatory if rtx is present.\n        if (typeof encoding.rtx.ssrc !== 'number') {\n            throw new TypeError('missing encoding.rtx.ssrc');\n        }\n    }\n    // dtx is optional. If unset set it to false.\n    if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {\n        encoding.dtx = false;\n    }\n    // scalabilityMode is optional.\n    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') {\n        throw new TypeError('invalid encoding.scalabilityMode');\n    }\n}\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpParameters(rtcp) {\n    if (typeof rtcp !== 'object') {\n        throw new TypeError('rtcp is not an object');\n    }\n    // cname is optional.\n    if (rtcp.cname && typeof rtcp.cname !== 'string') {\n        throw new TypeError('invalid rtcp.cname');\n    }\n    // reducedSize is optional. If unset set it to true.\n    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {\n        rtcp.reducedSize = true;\n    }\n}\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpCapabilities(caps) {\n    if (typeof caps !== 'object') {\n        throw new TypeError('caps is not an object');\n    }\n    // numStreams is mandatory.\n    if (!caps.numStreams || typeof caps.numStreams !== 'object') {\n        throw new TypeError('missing caps.numStreams');\n    }\n    validateNumSctpStreams(caps.numStreams);\n}\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateNumSctpStreams(numStreams) {\n    if (typeof numStreams !== 'object') {\n        throw new TypeError('numStreams is not an object');\n    }\n    // OS is mandatory.\n    if (typeof numStreams.OS !== 'number') {\n        throw new TypeError('missing numStreams.OS');\n    }\n    // MIS is mandatory.\n    if (typeof numStreams.MIS !== 'number') {\n        throw new TypeError('missing numStreams.MIS');\n    }\n}\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpParameters(params) {\n    if (typeof params !== 'object') {\n        throw new TypeError('params is not an object');\n    }\n    // port is mandatory.\n    if (typeof params.port !== 'number') {\n        throw new TypeError('missing params.port');\n    }\n    // OS is mandatory.\n    if (typeof params.OS !== 'number') {\n        throw new TypeError('missing params.OS');\n    }\n    // MIS is mandatory.\n    if (typeof params.MIS !== 'number') {\n        throw new TypeError('missing params.MIS');\n    }\n    // maxMessageSize is mandatory.\n    if (typeof params.maxMessageSize !== 'number') {\n        throw new TypeError('missing params.maxMessageSize');\n    }\n}\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpStreamParameters(params) {\n    if (typeof params !== 'object') {\n        throw new TypeError('params is not an object');\n    }\n    // streamId is mandatory.\n    if (typeof params.streamId !== 'number') {\n        throw new TypeError('missing params.streamId');\n    }\n    // ordered is optional.\n    let orderedGiven = false;\n    if (typeof params.ordered === 'boolean') {\n        orderedGiven = true;\n    }\n    else {\n        params.ordered = true;\n    }\n    // maxPacketLifeTime is optional.\n    if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') {\n        throw new TypeError('invalid params.maxPacketLifeTime');\n    }\n    // maxRetransmits is optional.\n    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {\n        throw new TypeError('invalid params.maxRetransmits');\n    }\n    if (params.maxPacketLifeTime && params.maxRetransmits) {\n        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n    }\n    if (orderedGiven &&\n        params.ordered &&\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\n        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n    }\n    else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n        params.ordered = false;\n    }\n    // label is optional.\n    if (params.label && typeof params.label !== 'string') {\n        throw new TypeError('invalid params.label');\n    }\n    // protocol is optional.\n    if (params.protocol && typeof params.protocol !== 'string') {\n        throw new TypeError('invalid params.protocol');\n    }\n}\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n    const extendedRtpCapabilities = {\n        codecs: [],\n        headerExtensions: []\n    };\n    // Match media codecs and keep the order preferred by remoteCaps.\n    for (const remoteCodec of remoteCaps.codecs || []) {\n        if (isRtxCodec(remoteCodec)) {\n            continue;\n        }\n        const matchingLocalCodec = (localCaps.codecs || [])\n            .find((localCodec) => (matchCodecs(localCodec, remoteCodec, { strict: true, modify: true })));\n        if (!matchingLocalCodec) {\n            continue;\n        }\n        const extendedCodec = {\n            mimeType: matchingLocalCodec.mimeType,\n            kind: matchingLocalCodec.kind,\n            clockRate: matchingLocalCodec.clockRate,\n            channels: matchingLocalCodec.channels,\n            localPayloadType: matchingLocalCodec.preferredPayloadType,\n            localRtxPayloadType: undefined,\n            remotePayloadType: remoteCodec.preferredPayloadType,\n            remoteRtxPayloadType: undefined,\n            localParameters: matchingLocalCodec.parameters,\n            remoteParameters: remoteCodec.parameters,\n            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n        };\n        extendedRtpCapabilities.codecs.push(extendedCodec);\n    }\n    // Match RTX codecs.\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const matchingLocalRtxCodec = localCaps.codecs\n            .find((localCodec) => (isRtxCodec(localCodec) &&\n            localCodec.parameters.apt === extendedCodec.localPayloadType));\n        const matchingRemoteRtxCodec = remoteCaps.codecs\n            .find((remoteCodec) => (isRtxCodec(remoteCodec) &&\n            remoteCodec.parameters.apt === extendedCodec.remotePayloadType));\n        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n        }\n    }\n    // Match header extensions.\n    for (const remoteExt of remoteCaps.headerExtensions) {\n        const matchingLocalExt = localCaps.headerExtensions\n            .find((localExt) => (matchHeaderExtensions(localExt, remoteExt)));\n        if (!matchingLocalExt) {\n            continue;\n        }\n        const extendedExt = {\n            kind: remoteExt.kind,\n            uri: remoteExt.uri,\n            sendId: matchingLocalExt.preferredId,\n            recvId: remoteExt.preferredId,\n            encrypt: matchingLocalExt.preferredEncrypt,\n            direction: 'sendrecv'\n        };\n        switch (remoteExt.direction) {\n            case 'sendrecv':\n                extendedExt.direction = 'sendrecv';\n                break;\n            case 'recvonly':\n                extendedExt.direction = 'sendonly';\n                break;\n            case 'sendonly':\n                extendedExt.direction = 'recvonly';\n                break;\n            case 'inactive':\n                extendedExt.direction = 'inactive';\n                break;\n        }\n        extendedRtpCapabilities.headerExtensions.push(extendedExt);\n    }\n    return extendedRtpCapabilities;\n}\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n    const rtpCapabilities = {\n        codecs: [],\n        headerExtensions: []\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remotePayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpCapabilities.codecs.push(codec);\n        // Add RTX codec.\n        if (!extendedCodec.remoteRtxPayloadType) {\n            continue;\n        }\n        const rtxCodec = {\n            mimeType: `${extendedCodec.kind}/rtx`,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n            clockRate: extendedCodec.clockRate,\n            parameters: {\n                apt: extendedCodec.remotePayloadType\n            },\n            rtcpFeedback: []\n        };\n        rtpCapabilities.codecs.push(rtxCodec);\n        // TODO: In the future, we need to add FEC, CN, etc, codecs.\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions not valid for receiving.\n        if (extendedExtension.direction !== 'sendrecv' &&\n            extendedExtension.direction !== 'recvonly') {\n            continue;\n        }\n        const ext = {\n            kind: extendedExtension.kind,\n            uri: extendedExtension.uri,\n            preferredId: extendedExtension.recvId,\n            preferredEncrypt: extendedExtension.encrypt,\n            direction: extendedExtension.direction\n        };\n        rtpCapabilities.headerExtensions.push(ext);\n    }\n    return rtpCapabilities;\n}\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {}\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind) {\n            continue;\n        }\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType\n                },\n                rtcpFeedback: []\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {}\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    return rtpParameters;\n}\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {}\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind) {\n            continue;\n        }\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.remoteParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType\n                },\n                rtcpFeedback: []\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {}\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n    if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01'))) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => fb.type !== 'goog-remb');\n        }\n    }\n    else if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time'))) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => fb.type !== 'transport-cc');\n        }\n    }\n    else {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => (fb.type !== 'transport-cc' &&\n                fb.type !== 'goog-remb'));\n        }\n    }\n    return rtpParameters;\n}\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\nfunction reduceCodecs(codecs, capCodec) {\n    const filteredCodecs = [];\n    // If no capability codec is given, take the first one (and RTX).\n    if (!capCodec) {\n        filteredCodecs.push(codecs[0]);\n        if (isRtxCodec(codecs[1])) {\n            filteredCodecs.push(codecs[1]);\n        }\n    }\n    // Otherwise look for a compatible set of codecs.\n    else {\n        for (let idx = 0; idx < codecs.length; ++idx) {\n            if (matchCodecs(codecs[idx], capCodec)) {\n                filteredCodecs.push(codecs[idx]);\n                if (isRtxCodec(codecs[idx + 1])) {\n                    filteredCodecs.push(codecs[idx + 1]);\n                }\n                break;\n            }\n        }\n        if (filteredCodecs.length === 0) {\n            throw new TypeError('no matching codec found');\n        }\n    }\n    return filteredCodecs;\n}\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n    // Clone given reference video RTP parameters.\n    videoRtpParameters = utils.clone(videoRtpParameters, {});\n    // This may throw.\n    validateRtpParameters(videoRtpParameters);\n    const rtpParameters = {\n        mid: RTP_PROBATOR_MID,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],\n        rtcp: { cname: 'probator' }\n    };\n    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n    return rtpParameters;\n}\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\nfunction canSend(kind, extendedRtpCapabilities) {\n    return extendedRtpCapabilities.codecs.\n        some((codec) => codec.kind === kind);\n}\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n    // This may throw.\n    validateRtpParameters(rtpParameters);\n    if (rtpParameters.codecs.length === 0) {\n        return false;\n    }\n    const firstMediaCodec = rtpParameters.codecs[0];\n    return extendedRtpCapabilities.codecs\n        .some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\nexports.canReceive = canReceive;\nfunction isRtxCodec(codec) {\n    if (!codec) {\n        return false;\n    }\n    return /.+\\/rtx$/i.test(codec.mimeType);\n}\nfunction matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {\n    const aMimeType = aCodec.mimeType.toLowerCase();\n    const bMimeType = bCodec.mimeType.toLowerCase();\n    if (aMimeType !== bMimeType) {\n        return false;\n    }\n    if (aCodec.clockRate !== bCodec.clockRate) {\n        return false;\n    }\n    if (aCodec.channels !== bCodec.channels) {\n        return false;\n    }\n    // Per codec special checks.\n    switch (aMimeType) {\n        case 'video/h264':\n            {\n                if (strict) {\n                    const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n                    const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n                    if (aPacketizationMode !== bPacketizationMode) {\n                        return false;\n                    }\n                    if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {\n                        return false;\n                    }\n                    let selectedProfileLevelId;\n                    try {\n                        selectedProfileLevelId =\n                            h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                    if (modify) {\n                        if (selectedProfileLevelId) {\n                            aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                            bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                        }\n                        else {\n                            delete aCodec.parameters['profile-level-id'];\n                            delete bCodec.parameters['profile-level-id'];\n                        }\n                    }\n                }\n                break;\n            }\n        case 'video/vp9':\n            {\n                if (strict) {\n                    const aProfileId = aCodec.parameters['profile-id'] || 0;\n                    const bProfileId = bCodec.parameters['profile-id'] || 0;\n                    if (aProfileId !== bProfileId) {\n                        return false;\n                    }\n                }\n                break;\n            }\n    }\n    return true;\n}\nfunction matchHeaderExtensions(aExt, bExt) {\n    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {\n        return false;\n    }\n    if (aExt.uri !== bExt.uri) {\n        return false;\n    }\n    return true;\n}\nfunction reduceRtcpFeedback(codecA, codecB) {\n    const reducedRtcpFeedback = [];\n    for (const aFb of codecA.rtcpFeedback || []) {\n        const matchingBFb = (codecB.rtcpFeedback || [])\n            .find((bFb) => (bFb.type === aFb.type &&\n            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter))));\n        if (matchingBFb) {\n            reducedRtcpFeedback.push(matchingBFb);\n        }\n    }\n    return reducedRtcpFeedback;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}