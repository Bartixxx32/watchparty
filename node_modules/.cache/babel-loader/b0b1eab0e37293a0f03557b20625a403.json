{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;\n\nvar sdpTransform = __importStar(require(\"sdp-transform\"));\n/**\n * This function must be called with an SDP with 1 m=audio and 1 m=video\n * sections.\n */\n\n\nfunction extractRtpCapabilities(_ref) {\n  var sdpObject = _ref.sdpObject;\n  // Map of RtpCodecParameters indexed by payload type.\n  var codecsMap = new Map(); // Array of RtpHeaderExtensions.\n\n  var headerExtensions = []; // Whether a m=audio/video section has been already found.\n\n  var gotAudio = false;\n  var gotVideo = false;\n\n  var _iterator = _createForOfIteratorHelper(sdpObject.media),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var m = _step.value;\n      var kind = m.type;\n\n      switch (kind) {\n        case 'audio':\n          {\n            if (gotAudio) {\n              continue;\n            }\n\n            gotAudio = true;\n            break;\n          }\n\n        case 'video':\n          {\n            if (gotVideo) {\n              continue;\n            }\n\n            gotVideo = true;\n            break;\n          }\n\n        default:\n          {\n            continue;\n          }\n      } // Get codecs.\n\n\n      var _iterator2 = _createForOfIteratorHelper(m.rtp),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var rtp = _step2.value;\n          var codec = {\n            kind: kind,\n            mimeType: \"\".concat(kind, \"/\").concat(rtp.codec),\n            preferredPayloadType: rtp.payload,\n            clockRate: rtp.rate,\n            channels: rtp.encoding,\n            parameters: {},\n            rtcpFeedback: []\n          };\n          codecsMap.set(codec.preferredPayloadType, codec);\n        } // Get codec parameters.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(m.fmtp || []),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var fmtp = _step3.value;\n          var parameters = sdpTransform.parseParams(fmtp.config);\n\n          var _codec = codecsMap.get(fmtp.payload);\n\n          if (!_codec) {\n            continue;\n          } // Specials case to convert parameter value to string.\n\n\n          if (parameters && parameters.hasOwnProperty('profile-level-id')) {\n            parameters['profile-level-id'] = String(parameters['profile-level-id']);\n          }\n\n          _codec.parameters = parameters;\n        } // Get RTCP feedback for each codec.\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(m.rtcpFb || []),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var fb = _step4.value;\n          var feedback = {\n            type: fb.type,\n            parameter: fb.subtype\n          };\n\n          if (!feedback.parameter) {\n            delete feedback.parameter;\n          } // rtcp-fb payload is not '*', so just apply it to its corresponding\n          // codec.\n\n\n          if (fb.payload !== '*') {\n            var _codec2 = codecsMap.get(fb.payload);\n\n            if (!_codec2) {\n              continue;\n            }\n\n            _codec2.rtcpFeedback.push(feedback);\n          } // If rtcp-fb payload is '*' it must be applied to all codecs with same\n          // kind (with some exceptions such as RTX codec).\n          else {\n            var _iterator6 = _createForOfIteratorHelper(codecsMap.values()),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var _codec3 = _step6.value;\n\n                if (_codec3.kind === kind && !/.+\\/rtx$/i.test(_codec3.mimeType)) {\n                  _codec3.rtcpFeedback.push(feedback);\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          }\n        } // Get RTP header extensions.\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(m.ext || []),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var ext = _step5.value;\n\n          // Ignore encrypted extensions (not yet supported in mediasoup).\n          if (ext['encrypt-uri']) {\n            continue;\n          }\n\n          var headerExtension = {\n            kind: kind,\n            uri: ext.uri,\n            preferredId: ext.value\n          };\n          headerExtensions.push(headerExtension);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var rtpCapabilities = {\n    codecs: Array.from(codecsMap.values()),\n    headerExtensions: headerExtensions\n  };\n  return rtpCapabilities;\n}\n\nexports.extractRtpCapabilities = extractRtpCapabilities;\n\nfunction extractDtlsParameters(_ref2) {\n  var sdpObject = _ref2.sdpObject;\n  var mediaObject = (sdpObject.media || []).find(function (m) {\n    return m.iceUfrag && m.port !== 0;\n  });\n\n  if (!mediaObject) {\n    throw new Error('no active media section found');\n  }\n\n  var fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\n  var role;\n\n  switch (mediaObject.setup) {\n    case 'active':\n      role = 'client';\n      break;\n\n    case 'passive':\n      role = 'server';\n      break;\n\n    case 'actpass':\n      role = 'auto';\n      break;\n  }\n\n  var dtlsParameters = {\n    role: role,\n    fingerprints: [{\n      algorithm: fingerprint.type,\n      value: fingerprint.hash\n    }]\n  };\n  return dtlsParameters;\n}\n\nexports.extractDtlsParameters = extractDtlsParameters;\n\nfunction getCname(_ref3) {\n  var offerMediaObject = _ref3.offerMediaObject;\n  var ssrcCnameLine = (offerMediaObject.ssrcs || []).find(function (line) {\n    return line.attribute === 'cname';\n  });\n\n  if (!ssrcCnameLine) {\n    return '';\n  }\n\n  return ssrcCnameLine.value;\n}\n\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\n\nfunction applyCodecParameters(_ref4) {\n  var offerRtpParameters = _ref4.offerRtpParameters,\n      answerMediaObject = _ref4.answerMediaObject;\n\n  var _iterator7 = _createForOfIteratorHelper(offerRtpParameters.codecs),\n      _step7;\n\n  try {\n    var _loop = function _loop() {\n      var codec = _step7.value;\n      var mimeType = codec.mimeType.toLowerCase(); // Avoid parsing codec parameters for unhandled codecs.\n\n      if (mimeType !== 'audio/opus') {\n        return \"continue\";\n      }\n\n      var rtp = (answerMediaObject.rtp || []).find(function (r) {\n        return r.payload === codec.payloadType;\n      });\n\n      if (!rtp) {\n        return \"continue\";\n      } // Just in case.\n\n\n      answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n      var fmtp = answerMediaObject.fmtp.find(function (f) {\n        return f.payload === codec.payloadType;\n      });\n\n      if (!fmtp) {\n        fmtp = {\n          payload: codec.payloadType,\n          config: ''\n        };\n        answerMediaObject.fmtp.push(fmtp);\n      }\n\n      var parameters = sdpTransform.parseParams(fmtp.config);\n\n      switch (mimeType) {\n        case 'audio/opus':\n          {\n            var spropStereo = codec.parameters['sprop-stereo'];\n\n            if (spropStereo !== undefined) {\n              parameters.stereo = spropStereo ? 1 : 0;\n            }\n\n            break;\n          }\n      } // Write the codec fmtp.config back.\n\n\n      fmtp.config = '';\n\n      for (var _i = 0, _Object$keys = Object.keys(parameters); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n\n        if (fmtp.config) {\n          fmtp.config += ';';\n        }\n\n        fmtp.config += \"\".concat(key, \"=\").concat(parameters[key]);\n      }\n    };\n\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\n\nexports.applyCodecParameters = applyCodecParameters;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","applyCodecParameters","getCname","extractDtlsParameters","extractRtpCapabilities","sdpTransform","require","sdpObject","codecsMap","Map","headerExtensions","gotAudio","gotVideo","media","kind","type","rtp","codec","mimeType","preferredPayloadType","payload","clockRate","rate","channels","encoding","parameters","rtcpFeedback","set","fmtp","parseParams","config","String","rtcpFb","fb","feedback","parameter","subtype","push","values","test","ext","headerExtension","uri","preferredId","rtpCapabilities","codecs","Array","from","mediaObject","find","iceUfrag","port","Error","fingerprint","role","setup","dtlsParameters","fingerprints","algorithm","hash","offerMediaObject","ssrcCnameLine","ssrcs","line","attribute","offerRtpParameters","answerMediaObject","toLowerCase","r","payloadType","f","spropStereo","stereo","keys","key"],"sources":["/home/runner/work/watchparty/watchparty/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\n/**\n * This function must be called with an SDP with 1 m=audio and 1 m=video\n * sections.\n */\nfunction extractRtpCapabilities({ sdpObject }) {\n    // Map of RtpCodecParameters indexed by payload type.\n    const codecsMap = new Map();\n    // Array of RtpHeaderExtensions.\n    const headerExtensions = [];\n    // Whether a m=audio/video section has been already found.\n    let gotAudio = false;\n    let gotVideo = false;\n    for (const m of sdpObject.media) {\n        const kind = m.type;\n        switch (kind) {\n            case 'audio':\n                {\n                    if (gotAudio) {\n                        continue;\n                    }\n                    gotAudio = true;\n                    break;\n                }\n            case 'video':\n                {\n                    if (gotVideo) {\n                        continue;\n                    }\n                    gotVideo = true;\n                    break;\n                }\n            default:\n                {\n                    continue;\n                }\n        }\n        // Get codecs.\n        for (const rtp of m.rtp) {\n            const codec = {\n                kind: kind,\n                mimeType: `${kind}/${rtp.codec}`,\n                preferredPayloadType: rtp.payload,\n                clockRate: rtp.rate,\n                channels: rtp.encoding,\n                parameters: {},\n                rtcpFeedback: []\n            };\n            codecsMap.set(codec.preferredPayloadType, codec);\n        }\n        // Get codec parameters.\n        for (const fmtp of m.fmtp || []) {\n            const parameters = sdpTransform.parseParams(fmtp.config);\n            const codec = codecsMap.get(fmtp.payload);\n            if (!codec) {\n                continue;\n            }\n            // Specials case to convert parameter value to string.\n            if (parameters && parameters.hasOwnProperty('profile-level-id')) {\n                parameters['profile-level-id'] = String(parameters['profile-level-id']);\n            }\n            codec.parameters = parameters;\n        }\n        // Get RTCP feedback for each codec.\n        for (const fb of m.rtcpFb || []) {\n            const feedback = {\n                type: fb.type,\n                parameter: fb.subtype\n            };\n            if (!feedback.parameter) {\n                delete feedback.parameter;\n            }\n            // rtcp-fb payload is not '*', so just apply it to its corresponding\n            // codec.\n            if (fb.payload !== '*') {\n                const codec = codecsMap.get(fb.payload);\n                if (!codec) {\n                    continue;\n                }\n                codec.rtcpFeedback.push(feedback);\n            }\n            // If rtcp-fb payload is '*' it must be applied to all codecs with same\n            // kind (with some exceptions such as RTX codec).\n            else {\n                for (const codec of codecsMap.values()) {\n                    if (codec.kind === kind && !/.+\\/rtx$/i.test(codec.mimeType)) {\n                        codec.rtcpFeedback.push(feedback);\n                    }\n                }\n            }\n        }\n        // Get RTP header extensions.\n        for (const ext of m.ext || []) {\n            // Ignore encrypted extensions (not yet supported in mediasoup).\n            if (ext['encrypt-uri']) {\n                continue;\n            }\n            const headerExtension = {\n                kind: kind,\n                uri: ext.uri,\n                preferredId: ext.value\n            };\n            headerExtensions.push(headerExtension);\n        }\n    }\n    const rtpCapabilities = {\n        codecs: Array.from(codecsMap.values()),\n        headerExtensions: headerExtensions\n    };\n    return rtpCapabilities;\n}\nexports.extractRtpCapabilities = extractRtpCapabilities;\nfunction extractDtlsParameters({ sdpObject }) {\n    const mediaObject = (sdpObject.media || [])\n        .find((m) => (m.iceUfrag && m.port !== 0));\n    if (!mediaObject) {\n        throw new Error('no active media section found');\n    }\n    const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\n    let role;\n    switch (mediaObject.setup) {\n        case 'active':\n            role = 'client';\n            break;\n        case 'passive':\n            role = 'server';\n            break;\n        case 'actpass':\n            role = 'auto';\n            break;\n    }\n    const dtlsParameters = {\n        role,\n        fingerprints: [\n            {\n                algorithm: fingerprint.type,\n                value: fingerprint.hash\n            }\n        ]\n    };\n    return dtlsParameters;\n}\nexports.extractDtlsParameters = extractDtlsParameters;\nfunction getCname({ offerMediaObject }) {\n    const ssrcCnameLine = (offerMediaObject.ssrcs || [])\n        .find((line) => line.attribute === 'cname');\n    if (!ssrcCnameLine) {\n        return '';\n    }\n    return ssrcCnameLine.value;\n}\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\nfunction applyCodecParameters({ offerRtpParameters, answerMediaObject }) {\n    for (const codec of offerRtpParameters.codecs) {\n        const mimeType = codec.mimeType.toLowerCase();\n        // Avoid parsing codec parameters for unhandled codecs.\n        if (mimeType !== 'audio/opus') {\n            continue;\n        }\n        const rtp = (answerMediaObject.rtp || [])\n            .find((r) => r.payload === codec.payloadType);\n        if (!rtp) {\n            continue;\n        }\n        // Just in case.\n        answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n        let fmtp = answerMediaObject.fmtp\n            .find((f) => f.payload === codec.payloadType);\n        if (!fmtp) {\n            fmtp = { payload: codec.payloadType, config: '' };\n            answerMediaObject.fmtp.push(fmtp);\n        }\n        const parameters = sdpTransform.parseParams(fmtp.config);\n        switch (mimeType) {\n            case 'audio/opus':\n                {\n                    const spropStereo = codec.parameters['sprop-stereo'];\n                    if (spropStereo !== undefined) {\n                        parameters.stereo = spropStereo ? 1 : 0;\n                    }\n                    break;\n                }\n        }\n        // Write the codec fmtp.config back.\n        fmtp.config = '';\n        for (const key of Object.keys(parameters)) {\n            if (fmtp.config) {\n                fmtp.config += ';';\n            }\n            fmtp.config += `${key}=${parameters[key]}`;\n        }\n    }\n}\nexports.applyCodecParameters = applyCodecParameters;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}