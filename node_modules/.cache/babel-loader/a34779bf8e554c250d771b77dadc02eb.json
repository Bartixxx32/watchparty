{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _slicedToArray = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _asyncToGenerator = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _createClass = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _assertThisInitialized = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _wrapNativeSuper = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;\n\nvar Logger_1 = require(\"./Logger\");\n\nvar logger = new Logger_1.Logger();\n/**\n * Custom Error derived class used to reject pending tasks once stop() method\n * has been called.\n */\n\nvar AwaitQueueStoppedError = /*#__PURE__*/function (_Error) {\n  _inherits(AwaitQueueStoppedError, _Error);\n\n  var _super = _createSuper(AwaitQueueStoppedError);\n\n  function AwaitQueueStoppedError(message) {\n    var _this;\n\n    _classCallCheck(this, AwaitQueueStoppedError);\n\n    _this = _super.call(this, message !== null && message !== void 0 ? message : 'AwaitQueue stopped');\n    _this.name = 'AwaitQueueStoppedError'; // @ts-ignore\n\n    if (typeof Error.captureStackTrace === 'function') {\n      // @ts-ignore\n      Error.captureStackTrace(_assertThisInitialized(_this), AwaitQueueStoppedError);\n    }\n\n    return _this;\n  }\n\n  return _createClass(AwaitQueueStoppedError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.AwaitQueueStoppedError = AwaitQueueStoppedError;\n/**\n * Custom Error derived class used to reject pending tasks once removeTask()\n * method has been called.\n */\n\nvar AwaitQueueRemovedTaskError = /*#__PURE__*/function (_Error2) {\n  _inherits(AwaitQueueRemovedTaskError, _Error2);\n\n  var _super2 = _createSuper(AwaitQueueRemovedTaskError);\n\n  function AwaitQueueRemovedTaskError(message) {\n    var _this2;\n\n    _classCallCheck(this, AwaitQueueRemovedTaskError);\n\n    _this2 = _super2.call(this, message !== null && message !== void 0 ? message : 'AwaitQueue task removed');\n    _this2.name = 'AwaitQueueRemovedTaskError'; // @ts-ignore\n\n    if (typeof Error.captureStackTrace === 'function') {\n      // @ts-ignore\n      Error.captureStackTrace(_assertThisInitialized(_this2), AwaitQueueRemovedTaskError);\n    }\n\n    return _this2;\n  }\n\n  return _createClass(AwaitQueueRemovedTaskError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;\n\nvar AwaitQueue = /*#__PURE__*/function () {\n  function AwaitQueue() {\n    _classCallCheck(this, AwaitQueue);\n\n    // Queue of pending tasks (map of PendingTasks indexed by id).\n    this.pendingTasks = new Map(); // Incrementing PendingTask id.\n\n    this.nextTaskId = 0; // Whether stop() method is stopping all pending tasks.\n\n    this.stopping = false;\n  }\n\n  _createClass(AwaitQueue, [{\n    key: \"size\",\n    get: function get() {\n      return this.pendingTasks.size;\n    }\n  }, {\n    key: \"push\",\n    value: function () {\n      var _push = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(task, name) {\n        var _this3 = this;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                name = name !== null && name !== void 0 ? name : task.name;\n                logger.debug(\"push() [name:\".concat(name, \"]\"));\n\n                if (!(typeof task !== 'function')) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new TypeError('given task is not a function');\n\n              case 4:\n                if (name) {\n                  try {\n                    Object.defineProperty(task, 'name', {\n                      value: name\n                    });\n                  } catch (error) {}\n                }\n\n                return _context.abrupt(\"return\", new Promise(function (_resolve, _reject) {\n                  var pendingTask = {\n                    id: _this3.nextTaskId++,\n                    task: task,\n                    name: name,\n                    enqueuedAt: Date.now(),\n                    executedAt: undefined,\n                    completed: false,\n                    resolve: function resolve(result) {\n                      // pendingTask.resolve() can only be called in execute() method. Since\n                      // resolve() was called it means that the task successfully completed.\n                      // However the task may have been stopped before it completed (via\n                      // stop() or remove()) so its completed flag was already set. If this\n                      // is the case, abort here since next task (if any) is already being\n                      // executed.\n                      if (pendingTask.completed) {\n                        return;\n                      }\n\n                      pendingTask.completed = true; // Remove the task from the queue.\n\n                      _this3.pendingTasks.delete(pendingTask.id);\n\n                      logger.debug(\"resolving task [name:\".concat(pendingTask.name, \"]\")); // Resolve the task with the obtained result.\n\n                      _resolve(result); // Execute the next pending task (if any).\n\n\n                      var _this3$pendingTasks$v = _this3.pendingTasks.values(),\n                          _this3$pendingTasks$v2 = _slicedToArray(_this3$pendingTasks$v, 1),\n                          nextPendingTask = _this3$pendingTasks$v2[0]; // NOTE: During the resolve() callback the user app may have interacted\n                      // with the queue. For instance, the app may have pushed a task while\n                      // the queue was empty so such a task is already being executed. If so,\n                      // don't execute it twice.\n\n\n                      if (nextPendingTask && !nextPendingTask.executedAt) {\n                        void _this3.execute(nextPendingTask);\n                      }\n                    },\n                    reject: function reject(error) {\n                      // pendingTask.reject() can be called within execute() method if the\n                      // task completed with error. However it may have also been called in\n                      // stop() or remove() methods (before or while being executed) so its\n                      // completed flag was already set. If so, abort here since next task\n                      // (if any) is already being executed.\n                      if (pendingTask.completed) {\n                        return;\n                      }\n\n                      pendingTask.completed = true; // Remove the task from the queue.\n\n                      _this3.pendingTasks.delete(pendingTask.id);\n\n                      logger.debug(\"rejecting task [name:\".concat(pendingTask.name, \"]: %s\"), String(error)); // Reject the task with the obtained error.\n\n                      _reject(error); // Execute the next pending task (if any) unless stop() is running.\n\n\n                      if (!_this3.stopping) {\n                        var _this3$pendingTasks$v3 = _this3.pendingTasks.values(),\n                            _this3$pendingTasks$v4 = _slicedToArray(_this3$pendingTasks$v3, 1),\n                            nextPendingTask = _this3$pendingTasks$v4[0]; // NOTE: During the reject() callback the user app may have interacted\n                        // with the queue. For instance, the app may have pushed a task while\n                        // the queue was empty so such a task is already being executed. If so,\n                        // don't execute it twice.\n\n\n                        if (nextPendingTask && !nextPendingTask.executedAt) {\n                          void _this3.execute(nextPendingTask);\n                        }\n                      }\n                    }\n                  }; // Append task to the queue.\n\n                  _this3.pendingTasks.set(pendingTask.id, pendingTask); // And execute it if this is the only task in the queue.\n\n\n                  if (_this3.pendingTasks.size === 1) {\n                    void _this3.execute(pendingTask);\n                  }\n                }));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function push(_x, _x2) {\n        return _push.apply(this, arguments);\n      }\n\n      return push;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      logger.debug('stop()');\n      this.stopping = true;\n\n      var _iterator = _createForOfIteratorHelper(this.pendingTasks.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pendingTask = _step.value;\n          logger.debug(\"stop() | stopping task [name:\".concat(pendingTask.name, \"]\"));\n          pendingTask.reject(new AwaitQueueStoppedError());\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.stopping = false;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(taskIdx) {\n      logger.debug(\"remove() [taskIdx:\".concat(taskIdx, \"]\"));\n      var pendingTask = Array.from(this.pendingTasks.values())[taskIdx];\n\n      if (!pendingTask) {\n        logger.debug(\"stop() | no task with given idx [taskIdx:\".concat(taskIdx, \"]\"));\n        return;\n      }\n\n      pendingTask.reject(new AwaitQueueRemovedTaskError());\n    }\n  }, {\n    key: \"dump\",\n    value: function dump() {\n      var now = Date.now();\n      var idx = 0;\n      return Array.from(this.pendingTasks.values()).map(function (pendingTask) {\n        return {\n          idx: idx++,\n          task: pendingTask.task,\n          name: pendingTask.name,\n          enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,\n          executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0\n        };\n      });\n    }\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(pendingTask) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug(\"execute() [name:\".concat(pendingTask.name, \"]\"));\n\n                if (!pendingTask.executedAt) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error('task already being executed');\n\n              case 3:\n                pendingTask.executedAt = Date.now();\n                _context2.prev = 4;\n                _context2.next = 7;\n                return pendingTask.task();\n\n              case 7:\n                result = _context2.sent;\n                // Resolve the task with its resolved result (if any).\n                pendingTask.resolve(result);\n                _context2.next = 14;\n                break;\n\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](4);\n                // Reject the task with its rejected error.\n                pendingTask.reject(_context2.t0);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[4, 11]]);\n      }));\n\n      function execute(_x3) {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }]);\n\n  return AwaitQueue;\n}();\n\nexports.AwaitQueue = AwaitQueue;","map":{"version":3,"names":["Object","defineProperty","exports","value","AwaitQueue","AwaitQueueRemovedTaskError","AwaitQueueStoppedError","Logger_1","require","logger","Logger","message","name","Error","captureStackTrace","pendingTasks","Map","nextTaskId","stopping","size","task","debug","TypeError","error","Promise","resolve","reject","pendingTask","id","enqueuedAt","Date","now","executedAt","undefined","completed","result","delete","values","nextPendingTask","execute","String","set","taskIdx","Array","from","idx","map","enqueuedTime","executionTime"],"sources":["/home/runner/work/watchparty/watchparty/node_modules/awaitqueue/lib/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;\nconst Logger_1 = require(\"./Logger\");\nconst logger = new Logger_1.Logger();\n/**\n * Custom Error derived class used to reject pending tasks once stop() method\n * has been called.\n */\nclass AwaitQueueStoppedError extends Error {\n    constructor(message) {\n        super(message !== null && message !== void 0 ? message : 'AwaitQueue stopped');\n        this.name = 'AwaitQueueStoppedError';\n        // @ts-ignore\n        if (typeof Error.captureStackTrace === 'function') {\n            // @ts-ignore\n            Error.captureStackTrace(this, AwaitQueueStoppedError);\n        }\n    }\n}\nexports.AwaitQueueStoppedError = AwaitQueueStoppedError;\n/**\n * Custom Error derived class used to reject pending tasks once removeTask()\n * method has been called.\n */\nclass AwaitQueueRemovedTaskError extends Error {\n    constructor(message) {\n        super(message !== null && message !== void 0 ? message : 'AwaitQueue task removed');\n        this.name = 'AwaitQueueRemovedTaskError';\n        // @ts-ignore\n        if (typeof Error.captureStackTrace === 'function') {\n            // @ts-ignore\n            Error.captureStackTrace(this, AwaitQueueRemovedTaskError);\n        }\n    }\n}\nexports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;\nclass AwaitQueue {\n    constructor() {\n        // Queue of pending tasks (map of PendingTasks indexed by id).\n        this.pendingTasks = new Map();\n        // Incrementing PendingTask id.\n        this.nextTaskId = 0;\n        // Whether stop() method is stopping all pending tasks.\n        this.stopping = false;\n    }\n    get size() {\n        return this.pendingTasks.size;\n    }\n    async push(task, name) {\n        name = name !== null && name !== void 0 ? name : task.name;\n        logger.debug(`push() [name:${name}]`);\n        if (typeof task !== 'function') {\n            throw new TypeError('given task is not a function');\n        }\n        if (name) {\n            try {\n                Object.defineProperty(task, 'name', { value: name });\n            }\n            catch (error) { }\n        }\n        return new Promise((resolve, reject) => {\n            const pendingTask = {\n                id: this.nextTaskId++,\n                task: task,\n                name: name,\n                enqueuedAt: Date.now(),\n                executedAt: undefined,\n                completed: false,\n                resolve: (result) => {\n                    // pendingTask.resolve() can only be called in execute() method. Since\n                    // resolve() was called it means that the task successfully completed.\n                    // However the task may have been stopped before it completed (via\n                    // stop() or remove()) so its completed flag was already set. If this\n                    // is the case, abort here since next task (if any) is already being\n                    // executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`resolving task [name:${pendingTask.name}]`);\n                    // Resolve the task with the obtained result.\n                    resolve(result);\n                    // Execute the next pending task (if any).\n                    const [nextPendingTask] = this.pendingTasks.values();\n                    // NOTE: During the resolve() callback the user app may have interacted\n                    // with the queue. For instance, the app may have pushed a task while\n                    // the queue was empty so such a task is already being executed. If so,\n                    // don't execute it twice.\n                    if (nextPendingTask && !nextPendingTask.executedAt) {\n                        void this.execute(nextPendingTask);\n                    }\n                },\n                reject: (error) => {\n                    // pendingTask.reject() can be called within execute() method if the\n                    // task completed with error. However it may have also been called in\n                    // stop() or remove() methods (before or while being executed) so its\n                    // completed flag was already set. If so, abort here since next task\n                    // (if any) is already being executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));\n                    // Reject the task with the obtained error.\n                    reject(error);\n                    // Execute the next pending task (if any) unless stop() is running.\n                    if (!this.stopping) {\n                        const [nextPendingTask] = this.pendingTasks.values();\n                        // NOTE: During the reject() callback the user app may have interacted\n                        // with the queue. For instance, the app may have pushed a task while\n                        // the queue was empty so such a task is already being executed. If so,\n                        // don't execute it twice.\n                        if (nextPendingTask && !nextPendingTask.executedAt) {\n                            void this.execute(nextPendingTask);\n                        }\n                    }\n                }\n            };\n            // Append task to the queue.\n            this.pendingTasks.set(pendingTask.id, pendingTask);\n            // And execute it if this is the only task in the queue.\n            if (this.pendingTasks.size === 1) {\n                void this.execute(pendingTask);\n            }\n        });\n    }\n    stop() {\n        logger.debug('stop()');\n        this.stopping = true;\n        for (const pendingTask of this.pendingTasks.values()) {\n            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);\n            pendingTask.reject(new AwaitQueueStoppedError());\n        }\n        this.stopping = false;\n    }\n    remove(taskIdx) {\n        logger.debug(`remove() [taskIdx:${taskIdx}]`);\n        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];\n        if (!pendingTask) {\n            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);\n            return;\n        }\n        pendingTask.reject(new AwaitQueueRemovedTaskError());\n    }\n    dump() {\n        const now = Date.now();\n        let idx = 0;\n        return Array.from(this.pendingTasks.values()).map((pendingTask) => ({\n            idx: idx++,\n            task: pendingTask.task,\n            name: pendingTask.name,\n            enqueuedTime: pendingTask.executedAt\n                ? pendingTask.executedAt - pendingTask.enqueuedAt\n                : now - pendingTask.enqueuedAt,\n            executionTime: pendingTask.executedAt\n                ? now - pendingTask.executedAt\n                : 0\n        }));\n    }\n    async execute(pendingTask) {\n        logger.debug(`execute() [name:${pendingTask.name}]`);\n        if (pendingTask.executedAt) {\n            throw new Error('task already being executed');\n        }\n        pendingTask.executedAt = Date.now();\n        try {\n            const result = await pendingTask.task();\n            // Resolve the task with its resolved result (if any).\n            pendingTask.resolve(result);\n        }\n        catch (error) {\n            // Reject the task with its rejected error.\n            pendingTask.reject(error);\n        }\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}